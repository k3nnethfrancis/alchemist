# Graph Build Notes

This document outlines the Alchemist Graph system in-depth, covering design goals, architectural considerations, node interactions, state management, context injection, subgraphs, error handling, and future enhancements.

---

## Table of Contents
1. Overview of the Graph System  
2. Architectural Components  
   1. Node Abstraction  
   2. Graph Execution Model  
   3. State Management & Checkpointing
   4. Event System & Monitoring
3. Current Status & Known Issues  
4. Proposed Enhancements  
5. Implementation Notes  
6. Future Plans & Next Steps  

---

## 1. Overview of the Graph System

The Alchemist Graph system provides a flexible, asynchronous workflow engine for orchestrating AI operations. A "Graph" is composed of nodes that each represents a single unit of work, such as:

• Calling an LLM (AgentNode)  
• Executing a tool (ActionNode)  
• Injecting external context (ContextNode)  
• Terminating workflows (TerminalNode)  

The graph routes from node to node based on success or error outcomes, and it stores intermediate results in a state object (NodeState). This model enables complex sequences of AI interactions while remaining provider-agnostic and easily composable.

---

## 2. Architectural Components

### 2.1 Node Abstraction

Current Implementation:
- Base Node class provides:
  * Standardized event emission
  * Input mapping with dotted notation
  * State validation and preparation
  * Logging with color coding
  * Performance tracking

Node Types:
1. ActionNode
   - Unified tool execution
   - State preservation
   - Pre/post execution hooks
   - Automatic timing
   - Color-coded logging

2. AgentNode
   - Direct Mirascope integration
   - Prompt templating
   - System prompt configuration
   - Conversation state management

3. ContextNode (In Progress)
   - Placeholder for memory system
   - Will support Supabase integration
   - External context injection

4. TerminalNode
   - Clean workflow termination
   - Status marking

### 2.2 Graph Execution Model

The Graph class manages:
• Node registration and chaining  
• Entry points  
• Run logic  
• Orchestrating transitions  
• Parallel execution support  
• Loop handling  
• Error routing  

### 2.3 State Management & Data Access

• NodeState stores:
  – results: node outputs
  – data: shared context
  – errors: exceptions
  – status: node execution status

• Data Access via input_map:
  – Supports dotted notation: "node.previous.result" or "data.user.preferences"
  – Automatic validation and error handling
  – Nested dictionary traversal

### 2.4 Event System & Monitoring

- Standardized NodeEvent enum
- Event emission for node lifecycle:
  * STARTED
  * TOOL_CALLED
  * TOOL_COMPLETED
  * COMPLETED
  * ERROR
- Support for real-time frontend monitoring
- Color-coded console output
- Timing information for performance tracking

---

## 3. Current Status & Known Issues

1. **Core Features**: Base Node, ActionNode, AgentNode, and TerminalNode are stable  
2. **ContextNode**: In development for memory system integration  
3. **Event System**: Implemented but needs frontend integration examples  
4. **Logging**: Enhanced with color coding and performance metrics  
5. **State Management**: Improved with dotted notation and validation

---

## 4. Implementation Notes

### 4.1 Node Development
- All nodes inherit from base Node class
- Standard event emission pattern
- Consistent error handling
- Performance tracking built-in

### 4.2 Logging System
- Color-coded output for different states
- Structured logging format
- Performance metrics included
- Support for frontend integration

### 4.3 State Management
- Dotted notation for data access
- Automatic validation
- Status tracking
- Error collection

---

## 5. Implementation Priorities

1. **Callback System**
   - Node lifecycle events
   - Tool execution monitoring
   - Error handling callbacks
   - Performance tracking
   - Frontend integration hooks

2. **Parallel Execution**
   - Parallel node execution
   - Tool parallelization
   - Resource management
   - State synchronization
   - Error handling

3. **Subgraph Support**
   - Nested workflow definition
   - State scoping
   - Error propagation
   - Composition patterns
   - Reusable workflows

4. **Error Handling**
   - Standardized error types
   - Recovery strategies
   - Fallback patterns
   - Error reporting
   - Debugging support

5. **Testing Framework**
   - Unit test suite
   - Integration tests
   - Performance tests
   - Error scenario tests
   - Example workflow tests

## 6. Example Patterns

Here are key workflow patterns supported by the system:

"""python
# 1. Basic Sequential Chain
workflow = chain([
    LLMNode(id="parse", input_map={"text": "user_input"}),
    ToolNode(id="fetch", input_map={"query": "parse.result"}),
    TerminalNode(id="end")
])

# 2. Loop Pattern
analyze = LLMNode(
    id="analyze",
    input_map={
        "content": "fetch.result",
        "previous": "analyze.result"
    },
    loop_condition="needs_refinement",
    max_loops=3
)

# 3. Nested Data Access
process = ToolNode(
    id="process",
    input_map={
        "user_id": "request.user.id",
        "settings": "config.user.preferences.default"
    }
)

# 4. Error Handling with Fallback
try_api = ToolNode(
    id="api_call",
    input_map={"params": "request.data"},
    next_nodes={
        "default": "success",
        "error": "fallback"
    }
)
"""