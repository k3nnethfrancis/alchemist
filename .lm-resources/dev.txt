# Alchemist Development Notes

This document serves as a living overview for the Alchemist project: an AI agent orchestration library used internally by Agency42. It provides details on the overall system architecture, our project structure, current development status, and future roadmap.

---

## 1. Project Structure

Below is the current layout of the Alchemist repository. It reflects how we organize core AI logic (agents, tools, graph), integration layers (extensions, logging), tests, and example projects.

alchemist/  
├── alchemist/                      # Main package  
│   ├── ai/  
│   │   ├── base/                   # [CORE]  
│   │   │   ├── agent.py           # Provider-agnostic BaseAgent [DONE]  
│   │   │   ├── logging.py         # Centralized logging system [DONE]  
│   │   │   └── runtime.py         # Environment management [DONE]  
│   │   ├── graph/                  # [CORE - IN PROGRESS ~85%]  
│   │   │   ├── base.py            # Core graph framework  
│   │   │   ├── state.py           # State management  
│   │   │   ├── config.py          # Graph configuration  
│   │   │   ├── viz.py             # Graph visualization [NEW]
│   │   │   └── nodes/  
│   │   │       ├── base/          # Base node implementations  
│   │   │       │   ├── node.py    # Abstract base node [DONE]  
│   │   │       ├── actions.py     # Enhanced action node [DONE]  
│   │   │       ├── agent.py       # Agent node implementation [DONE]  
│   │   │       ├── context.py     # Context management [IN PROGRESS]  
│   │   │       └── terminal.py    # Terminal node [DONE]  
│   │   ├── prompts/               # [CORE]  
│   │   │   ├── base.py           # Core prompt templates [DONE]  
│   │   │   └── persona.py        # Agent persona definitions [DONE]  
│   │   └── tools/                 # [CORE]  
│   │       ├── calculator.py      # Basic arithmetic tool [TESTED]  
│   │       ├── discord_toolkit.py    # Discord integration tool [COMPLETE]  
│   │       └── image.py           # Image generation tool [TESTED]  
│   ├── core/  
│   │   └── extensions/            # Platform integrations  
│   │       └── environments/      # Environment-specific code
│   │           └── discord/       # [COMPLETE]  
│   │               ├── client.py  # Discord bot client  
│   │               └── runtime.py # Discord runtime environment  
│   └── tests/                     # Test suite  
│       └── ai/  
│           └── graph/            # Graph system tests [IN PROGRESS]  
│               ├── nodes/        # Node implementation tests
│               │   ├── test_action_node.py
│               │   ├── test_base_node.py
│               │   ├── test_llm_node.py
│               │   └── test_tool_node.py
│               ├── test_base.py
│               ├── test_config.py
│               └── test_state.py
└── examples/                      # Example implementations  
    ├── discord/                   # Discord bot examples  
    │   ├── chatbot.py  
    │   └── run_bot.py  
    ├── graph/                     # Graph workflow examples [IN PROGRESS]  
    │   ├── analysis_workflow.py  
    │   ├── discord_workflow.py  
    │   └── newsletter_workflow.py  
    └── local_chatbot.py  

---

## 2. System Architecture Overview

Alchemist is built around two major subsystems:

1. **Agent System** (in alchemist/ai/base/agent.py, plus supporting modules):  
   - The agent is provider-agnostic and uses Mirascope as an abstraction layer for LLM calls.  
   - Agents can call tools, maintain conversation state, and either perform single-call (`_call`) or step-based (`_step`) interactions.  
   - We use Pydantic for data validation and docstrings to clearly specify usage.  

2. **Graph System** (in alchemist/ai/graph/):
   - Now includes standardized event emission system for real-time monitoring
   - Enhanced logging system with color-coded output for different node states
   - Supports both synchronous and asynchronous tool execution
   - Improved state management with dotted notation for data access
   - Built-in support for:
     * Input validation via Pydantic
     * Detailed logging of node execution steps
     * State preservation and cleanup
     * Callback hooks for node completion

Information flows like this:  
1. An Agent receives user input.
2. The Graph system orchestrates which node to call next.
3. Each node maps its required inputs from NodeState using input_map.
4. The node processes data (LLM call, tool execution, etc.).
5. Results are stored in NodeState, which can be persisted by StateManager.

---

## 3. Core Features & Capabilities

1. **Provider-Agnostic LLM Integration**  
   - Mirascope allows us to easily switch between GPT-4o-mini, Claude-3-5-sonnet, OpenPipe, or other providers.  
   - The agent code uses `_call` or `_step` to handle the conversation.  

2. **Tools & Action Nodes**  
   - Tools (calculator, image generation, Discord, etc.) can be invoked either by the agent or directly from the Graph.  
   - ActionNode adds pre/post hooks for more advanced workflows.  

3. **Asynchronous Execution**  
   - Both the agent calls and the node processes are async to accommodate external I/O.  

4. **State Management & Data Mapping**
   - Enhanced dotted notation support (e.g., "node.previous.result" or "data.user.preferences")
   - Standardized event emission for frontend integration
   - Color-coded logging for better visibility
   - Automatic timing and performance tracking

5. **Workflow Patterns**
   - Chain utility for simple sequential node connections.
   - Support for parallel execution paths.
   - Loop control for repeated execution of workflow segments.
   - Built-in terminal nodes for clean workflow completion.

6. **Node Types**
   - ActionNode: Enhanced tool execution with state preservation
   - AgentNode: LLM integration with Mirascope
   - ContextNode: External data injection (placeholder for memory system)
   - TerminalNode: Clean workflow completion

7. **Extensions**  
   - The core/ directory contains platform-specific integrations (e.g., Discord), bots, and runtimes.  

---

## 4. Immediate Priorities & Roadmap

1. **Core Agent Enhancements**
   - Add streaming support to BaseAgent
   - Integrate memory system into BaseAgent
   - Enhance tool calling system
     * Parallel tool execution
     * Better error handling
     * Tool result validation
     * Tool chaining patterns

2. **Graph System Improvements**
   - Implement callback system
     * Node lifecycle events
     * Tool execution events
     * Error events
     * Performance metrics
   - Add parallel node execution
   - Implement subgraph support
     * Nested workflow composition
     * State inheritance
     * Error bubbling

3. **Testing & Reliability**
   - Rebuild test suite from scratch
   - Add comprehensive test cases:
     * Agent streaming
     * Tool parallelization
     * Graph callbacks
     * Memory integration
     * Error scenarios
   - Add integration tests
   - Add performance benchmarks

4. **Package Completion**
   - Improve documentation
   - Add more usage examples
   - Create quickstart guide
   - Add deployment guides
   - Create contribution guidelines

5. **Extensions & Examples**
   - Add Twitter integration
   - Create new agent examples:
     * Research agent
     * Writing agent
     * Analysis agent
   - Add more tools:
     * Web search
     * Document processing
     * Data analysis

---

## 5. Integration Patterns

1. **Using the Agent Directly**  
   - For simple scripts, instantiate BaseAgent, call `_call`, or run `agent.run()` for an interactive loop.  
   - Tools can be attached to the agent to handle user requests.  

2. **Using the Graph**  
   - Create a Graph, define nodes (LLMNode, ToolNode, ActionNode, etc.).  
   - Provide NodeState as input, run the graph from a specified start node.  
   - The Graph orchestrates calls to agent._step() or agent._call().  

3. **Runtime Integration**  
   - For specialized environments (e.g., Discord), rely on core/extensions/discord/ to handle inbound messages.  
   - The extension calls the Graph system or agent code in response to events.  

---

## 6. Example Usage

Below outlines common usage patterns with the enhanced Graph system:

```python
from alchemist.ai.graph import Graph, chain
from alchemist.ai.graph.nodes import LLMNode, ToolNode, TerminalNode
from alchemist.ai.graph.state import NodeState

# 1. Using the chain utility for simple workflows
workflow = chain([
    LLMNode(
        id="interpret",
        input_map={"query": "user_input"},
        prompt_template=interpret_prompt
    ),
    ToolNode(
        id="fetch",
        input_map={"search_term": "interpret.result"},
        tool=search_tool
    ),
    TerminalNode(id="end")
])

# 2. Creating loops in workflows
analyze_node = LLMNode(
    id="analyze",
    input_map={
        "content": "fetch.result",
        "previous_analysis": "analyze.result"  # Access previous iteration
    },
    loop_condition="needs_refinement",  # Will loop back if this condition is met
    max_loops=3
)

# 3. Using nested key lookups
request_node = ToolNode(
    id="api_call",
    input_map={
        "user_id": "request.user.id",
        "preferences": "user_data.settings.preferences"
    }
)

# 4. Running the workflow
state = NodeState()
state.set_data("user_input", "What's the weather in Paris?")
final_state = await graph.run("start", state)
```

---

## 7. Testing     

- The test suite lives in alchemist/tests/.  
- We use pytest for asynchronous tests of agent methods, graph workflows, and tools.  
- Additional usage patterns are documented in inline docstrings and example scripts.  

Key test folders:  
• alchemist/tests/ai/graph – Tests graph nodes, state management, parallel flows, error handling.  
• alchemist/tests/ai/tools – Tests each tool.  
• alchemist/tests/core/extensions – Tests platform-specific extensions (Discord, etc.).  

---

## 8. Conclusion & Future Directions

Alchemist aims to unify agent-based AI workflows with powerful, configurable graph orchestration. By leveraging pydantic, asynchronous calls, Mirascope LLMS, and flexible tool usage, we support a wide range of use-cases:

1. Interactive chatbots and tool usage.  
2. Automated workflows for summarizing, analyzing, or generating content.  
3. Context- and memory-driven flows using external data sources.  
4. Platform integrations (Discord, Slack, etc.) with minimal extra code.

Planned features (like robust checkpointing, subgraph composition, updated memory integration, and advanced error handling) are next milestones. The goal is to provide a production-ready framework that remains flexible, provider-agnostic, and easy to extend.

For inquiries, reach out to the Agency42 team or refer to our internal wiki for detailed guides!
