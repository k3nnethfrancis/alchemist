# Alchemist Development Notes

This document serves as a living overview for the Alchemist project: an AI agent orchestration library used internally by Agency42. It provides details on the overall system architecture, our project structure, current development status, and future roadmap.

---

## 1. Project Structure

Below is the current layout of the Alchemist repository. It reflects how we organize core AI logic (agents, tools, graph), integration layers (extensions, logging), tests, and example projects.

alchemist/  
├── alchemist/                      # Main package  
│   ├── ai/  
│   │   ├── base/                   # [CORE]  
│   │   │   ├── agent.py           # Provider-agnostic BaseAgent [DONE]  
│   │   │   ├── logging.py         # Centralized logging system [DONE]  
│   │   │   └── runtime.py         # Environment management [DONE]  
│   │   ├── graph/                  # [CORE - IN PROGRESS ~85%]  
│   │   │   ├── base.py            # Core graph framework and orchestration  
│   │   │   ├── state.py           # State and context management  
│   │   │   ├── config.py          # Graph-level configuration  
│   │   │   └── nodes/  
│   │   │       ├── base/          # Base node implementations  
│   │   │       │   ├── node.py    # Abstract base node [DONE]  
│   │   │       │   ├── llm.py     # LLM node implementation [DONE]  
│   │   │       │   └── tool.py    # Simple tool wrapper node [DONE]  
│   │   │       ├── actions.py     # Enhanced tool node w/ checks & hooks [DONE]  
│   │   │       └── context.py     # Context management node(s) [IN PROGRESS]  
│   │   ├── prompts/               # [CORE]  
│   │   │   ├── base.py           # Core prompt templates [DONE]  
│   │   │   └── persona.py        # Agent persona definitions [DONE]  
│   │   └── tools/                 # [CORE]  
│   │       ├── calculator.py      # Basic arithmetic tool [TESTED]  
│   │       ├── discord_tool.py    # Discord integration tool [COMPLETE]  
│   │       └── image.py           # Image generation tool [TESTED]  
│   ├── core/  
│   │   ├── extensions/            # Platform integrations  
│   │   │   ├── config.py         # Extension configuration [DONE]  
│   │   │   └── discord/          # [COMPLETE]  
│   │   │       ├── client.py     # Discord bot client  
│   │   │       └── runtime.py    # Discord-specific runtime environment  
│   │   └── logger.py             # Centralized logging (alternative to base/logging.py) [DONE]  
│   └── tests/                     # Test suite  
│       ├── ai/  
│       │   ├── base/             # Core agent tests [DONE]  
│       │   ├── graph/            # Graph system tests [IN PROGRESS]  
│       │   └── tools/            # Tool implementation tests [DONE]  
│       └── core/  
│           ├── extensions/       # Platform integration tests [DONE]  
│           └── mirascope/       # Mirascope integration tests [DONE]  
└── examples/                      # Example implementations  
    ├── discord/                   # Discord bot examples  
    │   ├── chatbot.py  
    │   └── run_bot.py  
    ├── graph/                     # Graph workflow examples [IN PROGRESS]  
    │   ├── analysis_workflow.py  
    │   ├── discord_workflow.py  
    │   └── newsletter_workflow.py  
    └── local_chatbot.py  

---

## 2. System Architecture Overview

Alchemist is built around two major subsystems:

1. **Agent System** (in alchemist/ai/base/agent.py, plus supporting modules):  
   - The agent is provider-agnostic and uses Mirascope as an abstraction layer for LLM calls.  
   - Agents can call tools, maintain conversation state, and either perform single-call (`_call`) or step-based (`_step`) interactions.  
   - We use Pydantic for data validation and docstrings to clearly specify usage.  

2. **Graph System** (in alchemist/ai/graph/):  
   - Provides a workflow framework for chaining together nodes that may call LLMs, tools, or context managers.
   - The `Graph` (base.py) orchestrates node execution, parallelization, and stateful transitions.
   - Nodes use input_map for explicit data mapping from NodeState, supporting nested key lookups.
   - Built-in support for workflow patterns like chaining, looping, and terminal nodes.
   - All nodes are validated via Pydantic models and use async processing.

Information flows like this:  
1. An Agent receives user input.
2. The Graph system orchestrates which node to call next.
3. Each node maps its required inputs from NodeState using input_map.
4. The node processes data (LLM call, tool execution, etc.).
5. Results are stored in NodeState, which can be persisted by StateManager.

---

## 3. Core Features & Capabilities

1. **Provider-Agnostic LLM Integration**  
   - Mirascope allows us to easily switch between GPT-4o-mini, Claude-3-5-sonnet, OpenPipe, or other providers.  
   - The agent code uses `_call` or `_step` to handle the conversation.  

2. **Tools & Action Nodes**  
   - Tools (calculator, image generation, Discord, etc.) can be invoked either by the agent or directly from the Graph.  
   - ActionNode adds pre/post hooks for more advanced workflows.  

3. **Asynchronous Execution**  
   - Both the agent calls and the node processes are async to accommodate external I/O.  

4. **State Management & Data Mapping**
   - The Graph tracks results and shared data in a NodeState object.
   - Nodes use input_map to explicitly declare and validate their data requirements.
   - Support for nested key lookups (e.g., "request.user.name") in NodeState.
   - Built-in TerminalNode for workflow completion.
   - Loop detection and controlled repetition of workflow segments.

5. **Workflow Patterns**
   - Chain utility for simple sequential node connections.
   - Support for parallel execution paths.
   - Loop control for repeated execution of workflow segments.
   - Built-in terminal nodes for clean workflow completion.

6. **Extensions**  
   - The core/ directory contains platform-specific integrations (e.g., Discord), bots, and runtimes.  

---

## 4. Development Status & Roadmap

### 4.1 Current Status

• Agent System:  
  - BaseAgent is fully operational, integrated with tools, tested, and uses Mirascope provider-agnostic calls.  
  - Logging is centralized in either `base/logging.py` or `core/logger.py`.  

• Graph System (~85% Complete):  
  - We have base Graph (state, config) and node types (LLMNode, ToolNode, ActionNode).  
  - Parallel execution in base.py, plus partial subgraph logic.  
  - ContextNode is partially implemented to handle external context (e.g., time, memory).  

• Tools (calculator, image, Discord integration):  
  - All tested or completed.  
  - Tools are straightforward function calls or asynchronous calls.  

• Extensions:  
  - Discord integration is stable.  
  - Config-based channel management done.  

• Examples:  
  - Some graph usage examples exist (analysis_workflow, newsletter_workflow).  
  - More thorough usage examples are in progress.  

### 4.2 Roadmap / Next Steps

1. **Context Management**  
   - Finalize ContextNode for memory/time/facts injection.  
   - Provide a consistent interface for external data fetch and injection into NodeState.  

2. **Checkpointing & Persistence**  
   - Use StateManager's "persist_state" method, but extend to external storage (e.g., Supabase).  
   - This will allow long-running flows to recover from interruptions.  

3. **Memory System**  
   - Introduce or unify with the context approach so that agent queries can pull relevant historical data.  
   - We plan to integrate Supabase with a memory library (RAG-style retrieval).  

4. **Subgraph & Parallel Workflows**  
   - Enhance the base Graph for nested subgraphs.  
   - Improve concurrency or parallel node execution.  

5. **Advanced Error Handling**  
   - Introduce retry logic, fallback nodes, or specialized "error" pathways.  

6. **Documentation & Testing**  
   - Expand test coverage for context, memory, parallel node flows.  
   - Provide end-to-end examples in "examples/graph/."  

---

## 5. Integration Patterns

1. **Using the Agent Directly**  
   - For simple scripts, instantiate BaseAgent, call `_call`, or run `agent.run()` for an interactive loop.  
   - Tools can be attached to the agent to handle user requests.  

2. **Using the Graph**  
   - Create a Graph, define nodes (LLMNode, ToolNode, ActionNode, etc.).  
   - Provide NodeState as input, run the graph from a specified start node.  
   - The Graph orchestrates calls to agent._step() or agent._call().  

3. **Runtime Integration**  
   - For specialized environments (e.g., Discord), rely on core/extensions/discord/ to handle inbound messages.  
   - The extension calls the Graph system or agent code in response to events.  

---

## 6. Example Usage

Below outlines common usage patterns with the enhanced Graph system:

```python
from alchemist.ai.graph import Graph, chain
from alchemist.ai.graph.nodes import LLMNode, ToolNode, TerminalNode
from alchemist.ai.graph.state import NodeState

# 1. Using the chain utility for simple workflows
workflow = chain([
    LLMNode(
        id="interpret",
        input_map={"query": "user_input"},
        prompt_template=interpret_prompt
    ),
    ToolNode(
        id="fetch",
        input_map={"search_term": "interpret.result"},
        tool=search_tool
    ),
    TerminalNode(id="end")
])

# 2. Creating loops in workflows
analyze_node = LLMNode(
    id="analyze",
    input_map={
        "content": "fetch.result",
        "previous_analysis": "analyze.result"  # Access previous iteration
    },
    loop_condition="needs_refinement",  # Will loop back if this condition is met
    max_loops=3
)

# 3. Using nested key lookups
request_node = ToolNode(
    id="api_call",
    input_map={
        "user_id": "request.user.id",
        "preferences": "user_data.settings.preferences"
    }
)

# 4. Running the workflow
state = NodeState()
state.set_data("user_input", "What's the weather in Paris?")
final_state = await graph.run("start", state)
```

---

## 7. Testing     

- The test suite lives in alchemist/tests/.  
- We use pytest for asynchronous tests of agent methods, graph workflows, and tools.  
- Additional usage patterns are documented in inline docstrings and example scripts.  

Key test folders:  
• alchemist/tests/ai/graph – Tests graph nodes, state management, parallel flows, error handling.  
• alchemist/tests/ai/tools – Tests each tool.  
• alchemist/tests/core/extensions – Tests platform-specific extensions (Discord, etc.).  

---

## 8. Conclusion & Future Directions

Alchemist aims to unify agent-based AI workflows with powerful, configurable graph orchestration. By leveraging pydantic, asynchronous calls, Mirascope LLMS, and flexible tool usage, we support a wide range of use-cases:

1. Interactive chatbots and tool usage.  
2. Automated workflows for summarizing, analyzing, or generating content.  
3. Context- and memory-driven flows using external data sources.  
4. Platform integrations (Discord, Slack, etc.) with minimal extra code.

Planned features (like robust checkpointing, subgraph composition, updated memory integration, and advanced error handling) are next milestones. The goal is to provide a production-ready framework that remains flexible, provider-agnostic, and easy to extend.

For inquiries, reach out to the Agency42 team or refer to our internal wiki for detailed guides!
