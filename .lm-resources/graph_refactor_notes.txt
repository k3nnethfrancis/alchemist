# Graph System Refactor Specification

## Current System Analysis

### Core Components Overview

1. **Base System** (`base.py`):
   - Graph orchestration
   - Node management
   - State handling
   - Parallel execution
   - Subgraph composition

2. **Node Types**:
   - **Base Nodes** (`nodes/base/`):
     - `node.py`: Abstract base node with core interface
     - `llm.py`: LLM interaction with prompt templates
     - `tool.py`: Tool execution with input mapping
   
   - **Specialized Nodes** (`nodes/`):
     - `actions.py`: Enhanced tool nodes with pre/post hooks
     - `context.py`: Context suppliers (time, facts, engagement)
     - `evaluators.py`: Information extraction and state building
     - `decisions.py`: LLM-based decision making

3. **State Management**:
   - `state.py`: Core state container and management
   - Context persistence
   - Results tracking
   - Error handling

### Current Issues

1. **Import Structure**:
   - Circular dependencies between base.py and node implementations
   - Need cleaner separation of core interfaces and implementations

2. **State Management**:
   - Scattered across multiple components
   - Inconsistent access patterns
   - Need centralized state API

3. **Node Implementation**:
   - Duplicate functionality between similar nodes
   - Mixed concerns in some implementations
   - Need clearer inheritance patterns

4. **Configuration**:
   - Configuration spread across different levels
   - Need unified configuration system

## Proposed Changes

### 1. Restructure Imports

```
alchemist/ai/graph/
├── core/
│   ├── base.py      # Core interfaces and types
│   ├── state.py     # State management
│   └── config.py    # Configuration
├── nodes/
│   ├── base/
│   │   ├── node.py  # Abstract base node
│   │   ├── llm.py   # LLM node
│   │   └── tool.py  # Tool node
│   ├── actions/     # Action nodes
│   ├── context/     # Context nodes
│   ├── eval/        # Evaluator nodes
│   └── decision/    # Decision nodes
```

### 2. Clean Up State Management

1. Move all state-related code to `state.py`:
   - NodeState
   - StateManager
   - Context management
   - Results tracking

2. Create clear state interfaces:
   ```python
   class StateAccess(Protocol):
       """Interface for state access."""
       def get_data(self, key: str) -> Any: ...
       def set_data(self, key: str, value: Any) -> None: ...
       def get_result(self, node_id: str) -> Dict[str, Any]: ...
   ```

### 3. Node Hierarchy

```
Node (Abstract Base)
├── LLMNode
│   ├── DecisionNode
│   └── EvaluatorNode
├── ToolNode
│   └── ActionNode
└── ContextNode
    ├── TimeContextNode
    ├── FactsContextNode
    └── EngagementContextNode
```

### 4. Configuration System

1. Create typed configuration models:
   ```python
   class NodeConfig(BaseModel):
       """Base configuration for nodes."""
       id: str
       type: str
       metadata: Dict[str, Any] = Field(default_factory=dict)

   class GraphConfig(BaseModel):
       """Graph configuration."""
       nodes: Dict[str, NodeConfig]
       entry_points: Dict[str, str]
       state_persistence: bool = False
   ```

2. Support configuration inheritance and overrides

### 5. Error Handling

1. Define specific error types:
   ```python
   class NodeError(Exception): ...
   class StateError(Exception): ...
   class ConfigError(Exception): ...
   ```

2. Implement consistent error handling patterns

### 6. Testing Strategy

1. Unit tests for each component
2. Integration tests for node combinations
3. End-to-end workflow tests
4. State management tests
5. Error handling tests

## Implementation Plan

1. **Phase 1: Core Restructuring**
   - Move interfaces to core/
   - Clean up import hierarchy
   - Implement state protocols

2. **Phase 2: Node Cleanup**
   - Refactor node implementations
   - Implement clean inheritance
   - Add missing functionality

3. **Phase 3: Configuration**
   - Implement configuration system
   - Add validation
   - Support overrides

4. **Phase 4: Testing**
   - Add comprehensive tests
   - Add performance tests
   - Document test patterns

## Migration Guide

1. Update imports to use new structure
2. Convert nodes to use new interfaces
3. Update configuration format
4. Add error handling
5. Update tests

## Documentation Needs

1. Architecture overview
2. Node implementation guide
3. Configuration reference
4. Testing patterns
5. Migration guide
